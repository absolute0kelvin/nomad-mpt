--- monad-0.12.5/category/core/keccak_impl.S	2025-12-16 06:17:19.000000000 +0800
+++ nomad-mpt/nomad-mpt-sys/depend/monad/category/core/keccak_impl.S	2025-12-25 18:36:14.271151611 +0800
@@ -1,15 +1,29 @@
-#if defined(__linux__) && defined(__ELF__)
+// MonadDB Keccak256 multi-architecture assembly wrapper
+// Supports: Linux x86_64 (AVX2/AVX512), Linux ARM64 (NEON + optional SHA3)
+// NOTE: Only Linux is supported. macOS and Windows are NOT supported.
+
+#if !defined(__linux__)
+    #error "Only Linux is supported. macOS and Windows are NOT supported."
+#endif
+
+#if defined(__ELF__)
 .section .note.GNU-stack,"",%progbits
 #endif
 
-#if defined(__x86_64__)
+// ============ x86_64: AVX2 or AVX512 ============
+#if defined(__x86_64__) || defined(_M_X64)
     #if defined(__AVX512F__)
         #include <crypto/sha/asm/keccak1600-avx512.S>
     #elif defined(__AVX2__)
         #include <crypto/sha/asm/keccak1600-avx2.S>
     #else
-        #error avx2 or avx512 required
+        #error x86_64 requires AVX2 or AVX512 support
     #endif
+
+// ============ ARM64: NEON + optional ARMv8.2 SHA3 (Linux only) ============
+#elif defined(__aarch64__) || defined(__arm64__)
+    #include <crypto/sha/asm/keccak1600-armv8.S>
+
 #else
-    #error unsupported arch
+    #error Unsupported architecture. Supported: x86_64 (AVX2/AVX512), aarch64 (NEON/SHA3)
 #endif
--- monad-0.12.5/category/core/keccak.c	2025-12-16 06:17:19.000000000 +0800
+++ nomad-mpt/nomad-mpt-sys/depend/monad/category/core/keccak.c	2025-12-25 17:55:56.825793436 +0800
@@ -20,12 +20,63 @@
 
 #define BLOCK_SIZE ((1600 - 2 * 256) / 8)
 
+// Base NEON implementation (all ARM64)
 extern size_t
 SHA3_absorb(uint64_t A[5][5], unsigned char const *inp, size_t len, size_t r);
 
+#if defined(__aarch64__) || defined(__arm64__) || defined(_M_ARM64)
+
+// ARMv8.2 SHA3 crypto extension implementation (Apple M1+, Graviton 3+, etc.)
+extern size_t
+SHA3_absorb_cext(uint64_t A[5][5], unsigned char const *inp, size_t len, size_t r);
+
+extern void
+SHA3_squeeze_cext(uint64_t A[5][5], unsigned char *out, size_t len, size_t r, int next);
+
+// ARM64 OpenSSL assembly has a 5th 'next' parameter for SHA3_squeeze
+// next=0 means this is the first squeeze call (normal case for Keccak256)
+extern void
+SHA3_squeeze(uint64_t A[5][5], unsigned char *out, size_t len, size_t r, int next);
+
+// Capability flag from arm_cpu_detect.c - matches OpenSSL arm_arch.h
+extern unsigned int OPENSSL_armcap_P;
+#define ARMV8_SHA3 (1 << 11)
+
+// Runtime dispatch based on CPU capabilities
+static inline size_t sha3_absorb(uint64_t A[5][5], unsigned char const *inp, size_t len, size_t r)
+{
+    if (OPENSSL_armcap_P & ARMV8_SHA3) {
+        return SHA3_absorb_cext(A, inp, len, r);
+    }
+    return SHA3_absorb(A, inp, len, r);
+}
+
+static inline void sha3_squeeze(uint64_t A[5][5], unsigned char *out, size_t len, size_t r)
+{
+    if (OPENSSL_armcap_P & ARMV8_SHA3) {
+        SHA3_squeeze_cext(A, out, len, r, 0);
+    } else {
+        SHA3_squeeze(A, out, len, r, 0);
+    }
+}
+
+#else  // x86_64 or other
+
 extern void
 SHA3_squeeze(uint64_t A[5][5], unsigned char *out, size_t len, size_t r);
 
+static inline size_t sha3_absorb(uint64_t A[5][5], unsigned char const *inp, size_t len, size_t r)
+{
+    return SHA3_absorb(A, inp, len, r);
+}
+
+static inline void sha3_squeeze(uint64_t A[5][5], unsigned char *out, size_t len, size_t r)
+{
+    SHA3_squeeze(A, out, len, r);
+}
+
+#endif  // __aarch64__
+
 void keccak256(
     unsigned char const *const in, unsigned long const len,
     unsigned char out[KECCAK256_SIZE])
@@ -35,14 +86,14 @@
 
     __builtin_memset(A, 0, sizeof(A));
 
-    size_t const rem = SHA3_absorb(A, in, len, BLOCK_SIZE);
+    size_t const rem = sha3_absorb(A, in, len, BLOCK_SIZE);
     if (rem > 0) {
         __builtin_memcpy(blk, &in[len - rem], rem);
     }
     __builtin_memset(&blk[rem], 0, BLOCK_SIZE - rem);
     blk[rem] = 0x01;
     blk[BLOCK_SIZE - 1] |= 0x80;
-    (void)SHA3_absorb(A, blk, BLOCK_SIZE, BLOCK_SIZE);
+    (void)sha3_absorb(A, blk, BLOCK_SIZE, BLOCK_SIZE);
 
-    SHA3_squeeze(A, out, 32, BLOCK_SIZE);
+    sha3_squeeze(A, out, 32, BLOCK_SIZE);
 }
--- /dev/null
+++ category/core/arm_cpu_detect.c
@@ -0,0 +1,95 @@
+// Copyright (C) 2025 Category Labs, Inc.
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+// ARM CPU feature detection for Keccak/SHA3 hardware acceleration
+// Reference: OpenSSL crypto/armcap.c
+
+#if defined(__aarch64__) || defined(__arm64__) || defined(_M_ARM64)
+
+#include <stdint.h>
+
+// Global capability flags, used by OpenSSL assembly code
+// This variable is referenced by keccak1600-armv8.S
+unsigned int OPENSSL_armcap_P = 0;
+
+// Capability bits - MUST match OpenSSL definitions in arm_arch.h exactly!
+// See: third_party/openssl/crypto/sha/asm/arm_arch.h
+#define ARMV7_NEON      (1 << 0)
+#define ARMV7_TICK      (1 << 1)
+#define ARMV8_AES       (1 << 2)
+#define ARMV8_SHA1      (1 << 3)
+#define ARMV8_SHA256    (1 << 4)
+#define ARMV8_PMULL     (1 << 5)
+#define ARMV8_SHA512    (1 << 6)
+#define ARMV8_CPUID     (1 << 7)
+#define ARMV8_RNG       (1 << 8)
+#define ARMV8_SM3       (1 << 9)
+#define ARMV8_SM4       (1 << 10)
+#define ARMV8_SHA3      (1 << 11)  // ARMv8.2 SHA3 extension - NOTE: bit 11, not 10!
+
+// ============ Linux ARM64 Detection ============
+#if defined(__linux__)
+
+#include <sys/auxv.h>
+
+// HWCAP bits for ARM64 (from asm/hwcap.h)
+#ifndef HWCAP_AES
+#define HWCAP_AES       (1 << 3)
+#endif
+#ifndef HWCAP_SHA1
+#define HWCAP_SHA1      (1 << 5)
+#endif
+#ifndef HWCAP_SHA2
+#define HWCAP_SHA2      (1 << 6)
+#endif
+#ifndef HWCAP_SHA3
+#define HWCAP_SHA3      (1 << 17)
+#endif
+#ifndef HWCAP_SHA512
+#define HWCAP_SHA512    (1 << 21)
+#endif
+
+__attribute__((constructor))
+static void monad_detect_arm_features(void)
+{
+    unsigned long hwcap = getauxval(AT_HWCAP);
+
+    // All ARM64 Linux systems have NEON
+    OPENSSL_armcap_P |= ARMV7_NEON;
+
+    if (hwcap & HWCAP_AES) {
+        OPENSSL_armcap_P |= ARMV8_AES;
+    }
+    if (hwcap & HWCAP_SHA1) {
+        OPENSSL_armcap_P |= ARMV8_SHA1;
+    }
+    if (hwcap & HWCAP_SHA2) {
+        OPENSSL_armcap_P |= ARMV8_SHA256;
+    }
+    if (hwcap & HWCAP_SHA3) {
+        OPENSSL_armcap_P |= ARMV8_SHA3;
+    }
+    if (hwcap & HWCAP_SHA512) {
+        OPENSSL_armcap_P |= ARMV8_SHA512;
+    }
+}
+
+// ============ Other Platforms: Not Supported ============
+#else
+#error "ARM64 is only supported on Linux. macOS and Windows are not supported."
+#endif // Platform detection
+
+#endif // __aarch64__
+
